"use strict";(self.webpackChunkfluidhost=self.webpackChunkfluidhost||[]).push([[65354],{19352:(e,t,i)=>{i.d(t,{S:()=>s});const s={RefreshTimerTriggered:"RefreshTimerTriggered",MandatoryLabelHandlerSetReadOnly:"MandatoryLabelHandlerSetReadOnly",MandatoryLabelHandlerResetReadOnly:"MandatoryLabelHandlerResetReadOnly",InformationProtectionServiceDisposed:"InformationProtectionServiceDisposed",LogExtractSensitivityDiscrepancy:"LogExtractSensitivityDiscrepancy",InformationProtectionServiceInstantiated:"InformationProtectionServiceInstantiated"}},20057:(e,t,i)=>{i.d(t,{N:()=>s});const s={ConfigureIrmCapabilitiesError:"ConfigureIrmCapabilitiesError",ConfigureMandatoryLabelError:"ConfigureMandatoryLabelError",ComponentLifecycleMissingError:"ComponentLifecycleMissingError",EnforceInformationProtectionError:"EnforceInformationProtectionError",GetAppliedLabelError:"GetAppliedLabelError",GetContainerAssignedLabelError:"GetContainerAssignedLabelError",GetContainerLabelsError:"GetContainerLabelsError",GetContainerPolicySettingsError:"GetContainerPolicySettingsError",GetDlpPolicyTipError:"GetDlpPolicyTipError",GetIrmCapabilitiesError:"GetIrmCapabilitiesError",GetLabelsError:"GetLabelsError",GetPolicySettingsError:"GetPolicySettingsError",GetWatermarkingError:"GetWatermarkingError",InitializationError:"InitializationError",InvalidLabelId:"InvalidLabelId",InvalidResolvedUrl:"InvalidResolvedUrl",InvalidTenantId:"InvalidTenantId",ProcessPolicySettingsError:"ProcessPolicySettingsError",RefreshLabelError:"RefreshLabelError",RemoveLabelError:"RemoveLabelError",SetLabelError:"SetLabelError"}},64993:(e,t,i)=>{i.d(t,{N:()=>s});const s={EnforceInformationProtection:"EnforceInformationProtection",EnforceMandatoryLabelExperience:"EnforceMandatoryLabelExperience",GetAppliedLabel:"GetAppliedLabel",GetDlpPolicyTip:"GetDlpPolicyTip",GetIsProtectionEnabled:"GetIsProtectionEnabled",GetIrmCapabilities:"GetIrmCapabilities",GetWatermarking:"GetWatermarking",RefreshLabel:"RefreshLabel",RemoveLabel:"RemoveLabel",SetLabel:"SetLabel",ProcessPolicySettings:"ProcessPolicySettings",InstantiatedByHost:"InstantiatedByHost",InstantiatedByFactory:"InstantiatedByFactory"}},75740:(e,t,i)=>{i.d(t,{n:()=>s});class s{ctor;optionalProviders;constructor(e,t){this.ctor=e,this.optionalProviders=t}get IContainerServiceFactoryHelper(){return this}instantiateContainerService(e){const t=e.synthesize(this.optionalProviders,void 0);return new this.ctor(t)}}},83126:(e,t,i)=>{i.r(t),i.d(t,{CacheKeys:()=>_,SharepointInformationProtectionService:()=>z,SharepointInformationProtectionServiceFactory:()=>Y});class s extends Map{set(e,t){return super.set(e,t.then()),this}get(e){return super.get(e)?.then()}}var r=i(60835),a=i(25532),o=i(27284);function n(e,t){const i=e.filter(e=>e.id===t);return 1===i.length?i[0]:void 0}var l=i(40635),d=i(74405),c=i(18206),u=i(29018),h=i(37805),g=i(93537),p=i(47860);const m={allowedAttributes:["term","scheme","rel","href","type","m:null","m:type"],allowedNamespaces:["http://www.w3.org/2005/Atom","http://schemas.microsoft.com/ado/2007/08/dataservices/metadata","http://schemas.microsoft.com/ado/2007/08/dataservices","http://www.georss.org/georss","http://www.opengis.net/gml"],allowedTags:["entry","id","category","link","title","updated","author","name","content","m:properties","d:AppliedActionsText","d:ComplianceUrl","d:GeneralText","d:OverrideOptions","d:LastProcessedTime","d:MatchedConditionDescriptions","d:element","d:TwoLetterISOLanguageName","d:GetDlpPolicyTip"]};function P(e,t){const i=e.getElementsByTagName(t);return 1===i.length&&i[0].textContent?i[0].textContent:""}var b=i(85874);const f="None";function y(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const i=[408,409,503];return e&&(0,b.e9)(e)&&i.push(709,710),t&&(0,b.s5)(e)&&i.push(404),{maxRetries:2,backoffFn:(0,h.FT)(500),filter:(0,g.sC)(i),respectRetryAfterHeader:!0}}function v(e){const t=[503];return e&&(0,b.e9)(e)&&t.push(709,710),{respectRetryAfterHeader:!0,maxRetries:3,filter:(0,g.sC)(t),backoffFn:(0,h.Ed)(100)}}const L="#microsoft.graph.security.addWatermarkAction",w="#microsoft.graph.security.metadataAction",I=2e4;function C(e){const t=e?.value?.filter(e=>{if(e["@odata.type"]===w)return e});return 1===t.length?t[0]:void 0}const E=e=>`${(0,p.o)(e)}/beta/`,S=e=>`${(0,p.o)(e)}/v1.0/`,M=["InformationProtectionPolicy.Read"];async function T(e,t,i,s,r,a){const o=a?.user.upn,n=(0,b.yg)(r),c=(0,b.md)(r),u="GetPolicyLabels";const h=n?function(e){const t=new URLSearchParams;return t.append("$filter","applicableTo has 'file'"),S(r?.audience??"Production")+(e&&!c?`users/${e}`:"me")+`/informationProtection/sensitivityLabels?${t.toString()}`}(o):E(r?.audience??"Production")+"me/security/informationProtection/sensitivityLabels?$filter=contentFormats/any(s:s eq 'file')",g=H(i,u);n&&g.set("Accept-Language","default");const p=new AbortController,m={getToken:e=>{if(e)return t.getToken(M,e);throw Error("Options must be specified")},url:h,retryPolicy:v(r),timeoutMs:I,additionalRequestHeaders:g,requestInit:{signal:p.signal}},P=s?(0,l.g)({...m,logger:s,nameForLogging:u,getAdditionalProps:async(e,t)=>({...(0,d.u)(e),hasUpn:!!o,shouldFilterUDPLabels:n,useMeInUrls:c})}):(0,l.y)(m),f=(await P).result;if(404===f.status)return p.abort(),[];if(!f.ok||200!==f.status)throw p.abort(),new Error(`${u} failed with status : ${f.status}`);const y=await f.json();return n?R(y.value,e):y.value}function R(e,t,i){if(!e)return[];const s=[];for(const r of e)if(t||!U(r.labelActions)){const e=A(r,i);s.push(e,...R(r.sublabels,t,e))}return s}function A(e,t){return{id:e.id,name:e.displayName,description:e.description??"",isActive:e.isEnabled,sensitivity:e.priority,tooltip:e.toolTip??"",color:e.color??"#000000",parent:t||null,hasProtection:k(e.labelActions),watermark:x(e.labelActions),isDefault:e.isDefault}}function x(e){const t=e?.find(e=>"#microsoft.graph.addWatermark"===e["@odata.type"]);if(void 0!==t?.text)return{fontName:t.fontName,fontColor:t.fontColor??"#000000",fontSize:t.fontSize,layout:t.orientation,text:t.text}}function N(e){return"encryptWith"in e}function k(e){return!!e&&e.some(e=>N(e)&&"template"===e.encryptWith)}function U(e){return!!e&&e.some(e=>N(e)&&"userDefinedRights"===e.encryptWith)}function D(e){return{metadata:[{name:`MSIP_Label_${e}_Enabled`,value:"true"}]}}async function G(e,t,i,s,r,a,o){const n=E(o?.audience??"Production")+"me/security/informationProtection/sensitivityLabels/evaluateApplication",l=H(i,"EvaluateApplication"),d={contentInfo:r||D(t),labelingOptions:{labelId:t,downgradeJustification:{isDowngradeJustified:!!s,justificationMessage:s||""}}},u=new AbortController,h=await(0,c.fV)(t=>e.getToken(M,t),n,o?.audience??"Production","EvaluateApplication",a,void 0,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(d),signal:u.signal},v(o),I,void 0,l);if(!h.ok||200!==h.status){if(u.abort(),400===h.status&&(0,b.s7)(o)){d.labelingOptions.downgradeJustification.justificationMessage="REDACTED";const e=JSON.stringify(d);throw new Error(`evaluateLabelApplication failed with status : ${h.status} and payload: ${e}`)}throw new Error(`evaluateLabelApplication failed with status : ${h.status}`)}const g=await h.json(),p=function(e){const t=e?.value?.filter(e=>{if(e["@odata.type"]===L)return e});return 1===t.length?t[0]:void 0}(g),m=C(g);return m?.metadataToAdd?{changeLabel:!0,contentInfo:{metadata:m.metadataToAdd},watermark:p}:{changeLabel:!1}}async function O(e,t,i,s,r,a,o,n){const h=(0,b.p3)(n)?await async function(e,t,i,s,r,a,o){const n=(0,u.$)(s),c=H(r,"extractSensitivityLabels"),h=new AbortController,g={getToken:r=>{if(r){const a={...r,siteUrl:s,driveId:i,itemId:t};return e.getToken([`${n}/files.readwrite.all`],a)}throw Error("Options must be specified")},url:`${n}/_api/v2.0/drives/${i}/items/${t}/oneDrive.extractSensitivityLabels`,requestInit:{method:"POST",headers:{"Content-Type":"application/json"},signal:h.signal},retryPolicy:y(o),timeoutMs:I,additionalRequestHeaders:c},p=a?await(0,l.g)({...g,logger:a,nameForLogging:"extractSensitivityLabels",getAdditionalProps:async(e,t)=>(0,d.u)(e)}):await(0,l.y)(g);if(!p.result.ok||200!==p.result.status)throw h.abort(),new Error(`extractInformationProtectionContentLabels failed with status : ${p.result.status}`);const m=await p.result.json();return m}(e,t,i,s,a,o,n):await async function(e,t,i,s,r,a,o,n){const l=new URL(s).hostname,d=`${S(n?.audience??"Production")}sites/${l}/drives/${i}/items/${t}/extractSensitivityLabels`,u=t=>e.getToken(["files.readwrite.all"],t),h=H(a,"extractSensitivityLabels"),g=new AbortController,p=await(0,c.fV)(u,d,n?.audience??"Production","extractSensitivityLabels",o,r,{method:"POST",signal:g.signal},v(n),I,void 0,h);if(!p.ok||200!==p.status)throw g.abort(),new Error(`extractInformationProtectionContentLabels failed with status : ${p.status}`);const m=await p.json();return m}(e,t,i,s,r,a,o,n);let g=h?.labels.find(e=>e.tenantId===r);return!g&&h?.labels.length&&h.labels.length>0&&(0,b.Ix)(n)&&(g=h.labels[0]),g}async function $(e,t,i,s,a,o,n,c){const h=(0,u.$)(s),g=H(o,"GetDlpPolicyTip"),p=await(0,r.OF)(e,s,i,t,n),f=p?.sharepointIds.listItemUniqueId,v=p?.webDavUrl.replace(h,""),L=(0,b.hP)(c),w=L&&f?`${s}/_api/web/getList('${v}')/getItemByUniqueId('${f}')/getDlpPolicyTip`:`${s}/_api/web/getListItem('${v}')/getdlppolicytip`,C=new AbortController,E={getToken:r=>{if(r){const a={...r,siteUrl:s,driveId:i,itemId:t};return e.getToken([`${h}/files.readwrite.all`],a)}throw Error("Options must be specified")},url:w,retryPolicy:y(c),timeoutMs:I,additionalRequestHeaders:g,requestInit:{signal:C.signal}},S=n?await(0,l.g)({...E,logger:n,nameForLogging:"GetDlpPolicyTip",getAdditionalProps:async(e,t)=>({...(0,d.u)(e),isFileIdUsedForDlpTip:L,hasGuid:!!f})}):await(0,l.y)(E);if(!S.result.ok||200!==S.result.status)throw C.abort(),new Error(`getDlpTooltip failed with status : ${S.result.status}`);const M=await S.result.text();return await async function(e,t){let i;i=t?(0,(await t).createXML)(e,m):e;const s=(new DOMParser).parseFromString(i,"text/xml"),r=s.querySelector("parsererror");if(r)throw new Error(`parseDlpPolicyTip failed to parse : ${r.textContent}`);const a=s.querySelector("content");if(a){const e=P(a,"d:GeneralText"),t=P(a,"d:AppliedActionsText"),i=P(a,"d:ComplianceUrl"),s=P(a,"d:OverrideOptions"),r=s?parseInt(s,10):void 0,o=P(a,"d:LastProcessedTime"),n=function(e,t){const i=e.getElementsByTagName(t),s=[];if(1===i.length)for(let r=0;r<i[0].children.length;r+=1){const e=i[0].children[r].textContent;s.push(e||"")}return s}(a,"d:MatchedConditionDescriptions");if([e,t,i,r,o,n.length].every(e=>!e))return;return{generalText:e,appliedActionsText:t,complianceUrl:i,overrideOptions:void 0!==r?r:NaN,lastProcessedTime:o,matchedConditionDescriptions:n}}}(M,a)}function H(e,t){const i=`${e.scenario||"InformationProtection"}_${e.subScenario||t||"Undefined"},`;return new Headers({Application:e.application||"Undefined",Scenario:i,ScenarioType:e.scenarioType,Version:e.appVersion||"0.0.0"})}var q=i(20057),W=i(19352),F=i(64993),j=i(83125),J=i(95996),V=i(33788),K=i(75740);const _={AppliedLabel:"AppliedLabel",IrmCapabilities:"IrmCapabilities",IsProtectionEnabled:"IsProtectionEnabled",PolicySettings:"PolicySettings",Watermark:"Watermark",DlpPolicyTip:"DlpPolicyTip",Labels:"Labels",UnfilteredLabels:"UnfilteredLabels",IsMandatoryLabelingRequired:"IsMandatoryLabelingRequired"};function B(e){return!!e&&"tokenProvider"in e}class z extends o.EventEmitter{constructor(e){super(),this.propsOrProviders=e,this.disposed=!1,this.assignedMode=!1,this.props=B(e)?e:void 0,this.providers=B(e)?void 0:e,this.existingHostLabel=this.props?.existingHostLabel,this.providers?.InformationProtectionContext&&this.providers.InformationProtectionContext.then(e=>{e&&(this.existingHostLabel=e.inheritedSensitivityLabel,e.assignedMode&&(this.assignedMode=!0,void 0!==e.assignedSensitivityLabelId&&this.setCurrentLabel(void 0,{id:e.assignedSensitivityLabelId,assignmentMethod:"standard",actionSource:"manual"},void 0,!0),void 0!==e.assignedCapabilities&&(this.assignedCapabilities=e.assignedCapabilities),this.supportsCLP=!!e.assignedCapabilities?.supportsCLP))});const t=this.providers?.NamespaceLogger?.then(e=>e?new j.p("InformationProtectionService",e):void 0);this.loggerPromise=this.props?.logger?Promise.resolve(this.props.logger):t,this.tokenProviderPromise=this.props?.tokenProvider?Promise.resolve(this.props.tokenProvider):this.providers?.TokenProvider,this.settingsProviderPromise=this.props?.settingsProvider?Promise.resolve(this.props.settingsProvider):this.providers?.SettingsProvider,this.userContextPromise=this.props?.userContext?Promise.resolve(this.props.userContext):this.providers?.UserContext,this.trustedTypesPolicyPromise=this.props?.trustedTypesPolicy?Promise.resolve(this.props.trustedTypesPolicy):this.providers?.LoopTrustedTypesPolicy,this.setMaxListeners(0),this.PromiseCache=new s,this.props?this.props.logger&&(0,J.Ot)(this.props.logger,{eventName:W.S.InformationProtectionServiceInstantiated,scenario:F.N.InstantiatedByHost}):this.providers&&this.providers.NamespaceLogger?.then(e=>{e&&(0,J.Ot)(e,{eventName:W.S.InformationProtectionServiceInstantiated,scenario:F.N.InstantiatedByFactory,assignedMode:this.assignedMode})})}clone(){if(this.props)return new z(this.props);if(this.providers)return new z(this.providers);throw new Error("Either props or providers must be set")}createAttributionHeaders(e){return{application:this.props?.applicationName||"Loop",appVersion:this.props?.appVersion||"0.0.0",scenarioType:e||"AUO",scenario:"InformationProtection"}}get Disposable(){return this}dispose(){this.disposed=!0,window.clearInterval(this.refreshTimer),window.clearTimeout(this.mandatoryLabelTimeout),this.removeAllListeners(),this.PromiseCache.clear(),this.labelMetadataCache=void 0,delete this.labelMetadataCache,delete this.refreshTimer,delete this.mandatoryLabelTimeout}get InformationProtectionService(){return this}static#e=(()=>this.serviceFactory=new K.n(z,{TokenProvider:"TokenProvider",NamespaceLogger:"NamespaceLogger",SettingsProvider:"SettingsProvider",UserContext:"UserContext",LoopTrustedTypesPolicy:"LoopTrustedTypesPolicy",InformationProtectionContext:"InformationProtectionContext"}))();isAssignedMode(e){return!!(0,b.CE)(e)&&this.assignedMode}async getSupportsCLP(e,t){return void 0===this.supportsCLP&&await this.getIrmInformation(e,t),this.supportsCLP}getCacheKey(e,t){if(void 0!==t)return e+"_"+t}async getCurrentLabel(e,t,i){const[s,o,n]=await Promise.all([this.tokenProviderPromise,this.loggerPromise,this.settingsProviderPromise]),l=V.m.start("GetAppliedLabel",o);if(this.isAssignedMode(n)){if(l.setResult(!0,{sensitivityLabelId:this.assignedSensitivityLabelId,assignedMode:this.assignedMode}),void 0===this.assignedSensitivityLabelId)return;return{sensitivityLabelId:this.assignedSensitivityLabelId,assignmentMethod:"standard",tenantId:""}}if(!e||!(0,r.g2)(e))return void(o&&(0,J.Ot)(o,{eventName:q.N.InvalidResolvedUrl,scenario:F.N.GetAppliedLabel}));if((0,b.N1)(n)){if(!1===await this.getSupportsCLP(e,t))return}const d=this.getCacheKey(_.AppliedLabel,e.hashedDocumentId);let c=d&&this.PromiseCache.get(d);return c||(c=(async()=>{try{const r=await(0,a.J)(e.siteUrl,o);if(!r)return void l.setResult(!1,{errorType:q.N.InvalidTenantId});if(void 0===s)throw new Error("TokenProvider is not available");const d=await O(s,e.itemId,e.driveId,e.siteUrl,r,this.createAttributionHeaders(t),o,n);return this.monitorAppliedLabel(e),i&&!d?void l.setResult(!0,{skipDefaultLabeling:i}):(this.processPolicySettings(e,d,"AUO"),l.setResult(!0,{appliedLabel:!!d,sensitivityLabelId:d?.sensitivityLabelId,assignmentMethod:d?.assignmentMethod,assignedMode:this.assignedMode}),d)}catch(r){return d&&this.PromiseCache.delete(d),void l.setResult(!1,{errorType:q.N.GetAppliedLabelError},r)}})(),d&&this.PromiseCache.set(d,c),c.then())}async getHasProtection(e,t){const[i,s]=await Promise.all([this.loggerPromise,this.settingsProviderPromise]);if(this.isAssignedMode(s)){if(void 0===this.assignedSensitivityLabelId)return;return this.assignedCapabilities?.supportsCLP??!1}if(!e||!(0,r.g2)(e))return void(i&&(0,J.Ot)(i,{eventName:q.N.InvalidResolvedUrl,scenario:F.N.GetIsProtectionEnabled}));if((0,b.N1)(s)){if(!1===await this.getSupportsCLP(e,t))return!1}const a=this.getCacheKey(_.IsProtectionEnabled,e.hashedDocumentId);let o=a&&this.PromiseCache.get(a);if(o)return o;const l=V.m.start("IsProtectionEnabled",i);return o=(async()=>{const[i,s]=await Promise.all([this.getCurrentLabel(e,t),this.getLabels(t,!0)]);if(i&&!s)return l.setResult(!1,{hasProtection:!1,appliedLabel:!!i,allLabels:!!s}),void(a&&this.PromiseCache.delete(a));let r=!1;if(i&&s){const e=n(s,i.sensitivityLabelId);r=!!e?.hasProtection}return l.setResult(!0,{appliedLabel:!!i,allLabels:!!s,hasProtection:r}),r})(),a&&this.PromiseCache.set(a,o),o.then()}async setIrmInformation(e,t,i){const[s,r]=await Promise.all([this.settingsProviderPromise,this.loggerPromise]);if(!this.isAssignedMode(s))throw new Error("Setting IRM capabilities is only supported in assigned mode");return V.m.start("SetIrmCapabilities",r).setResult(!0,{supportsCLP:t.supportsCLP,canWrite:t.canWrite,canExtract:t.canExtract,canPrint:t.canPrint,canExport:t.canExport,assignedMode:this.assignedMode}),this.assignedCapabilities=t,!0}async getIrmInformation(e,t){const[i,s,a]=await Promise.all([this.tokenProviderPromise,this.loggerPromise,this.settingsProviderPromise]),o=V.m.start("GetIrmCapabilities",s);if(this.isAssignedMode(a))return o.setResult(!0,{supportsCLP:this.assignedCapabilities?.supportsCLP,canWrite:this.assignedCapabilities?.canWrite,canExtract:this.assignedCapabilities?.canExtract,canPrint:this.assignedCapabilities?.canPrint,canExport:this.assignedCapabilities?.canExport,assignedMode:this.assignedMode}),this.assignedCapabilities;if(!e||!(0,r.g2)(e))return void(s&&(0,J.Ot)(s,{eventName:q.N.InvalidResolvedUrl,scenario:F.N.GetIrmCapabilities}));const n=this.createAttributionHeaders(t),c=this.getCacheKey(_.IrmCapabilities,e.hashedDocumentId);let h=c&&this.PromiseCache.get(c);return h||(h=(async()=>{try{if(void 0===i)throw new Error("TokenProvider is not available");const t=await async function(e,t,i,s,r,a,o){const n=(0,u.$)(s),c=H(r,"getItemIrmCapabilities"),h=new AbortController,g={getToken:r=>{if(r){const a={...r,siteUrl:s,driveId:i,itemId:t};return e.getToken([`${n}/files.readwrite.all`],a)}throw Error("Options must be specified")},url:`${s}/_api/v2.1/drives/${i}/items/${t}/opStream/capabilities?$select=canWrite,canPrint,canExtract,canExport,supportsCLP`,retryPolicy:y(o),timeoutMs:I,additionalRequestHeaders:c,requestInit:{signal:h.signal}},p=a?await(0,l.g)({...g,logger:a,nameForLogging:"GetItemIrmCapabilities",getAdditionalProps:async(e,t)=>(0,d.u)(e)}):await(0,l.y)(g);if(!p.result.ok||200!==p.result.status)throw h.abort(),new Error(`getItemIrmCapabilities failed with status : ${p.result.status}`);return await p.result.json()}(i,e.itemId,e.driveId,e.siteUrl,n,s,a);return this.supportsCLP=t.supportsCLP,o.setResult(!0,{supportsCLP:t.supportsCLP,canWrite:t.canWrite,canExtract:t.canExtract,canPrint:t.canPrint,canExport:t.canExport,assignedMode:this.assignedMode}),t}catch(t){return c&&this.PromiseCache.delete(c),o.setResult(!1,{errorType:q.N.GetIrmCapabilitiesError},t),void(this.supportsCLP=!1)}})(),c&&this.PromiseCache.set(c,h),h.then())}async getPolicySettings(e){const[t,i,s,r]=await Promise.all([this.tokenProviderPromise,this.loggerPromise,this.settingsProviderPromise,this.userContextPromise]);let a=this.PromiseCache.get(_.PolicySettings.toString());if(a)return a;const o=V.m.start("GetPolicySettings",i);return a=(async()=>{try{if(void 0===t)throw new Error("TokenProvider is not available");const a=await async function(e,t,i,s,r){const a=r?.user.upn,o=(0,b.Wy)(s),n=(0,b.md)(s),c="GetPolicySettings",u=o?function(e){const t=new URLSearchParams;return t.append("$filter","applicableTo has 'file'"),S(s?.audience??"Production")+(e&&!n?`users/${e}`:"me")+`/informationProtection/sensitivityPolicySettings?${t.toString()}`}(a):E(s?.audience??"Production")+"me/security/informationProtection/labelPolicySettings",h=H(t,c),g=new AbortController,p={getToken:t=>{if(t)return e.getToken(M,t);throw Error("Options must be specified")},url:u,retryPolicy:v(s),timeoutMs:I,additionalRequestHeaders:h,requestInit:{signal:g.signal}},m=i?(0,l.g)({...p,logger:i,nameForLogging:c,getAdditionalProps:async(e,t)=>({...(0,d.u)(e),hasUpn:!!a,useNewAPI:o,useMeInUrls:n})}):(0,l.y)(p),P=(await m).result;if(404===P.status||204===P.status)return g.abort(),{id:"",moreInfoUrl:"",isDowngradeJustificationRequired:!1,isMandatory:!1,defaultLabelId:""};if(!P.ok||200!==P.status)throw g.abort(),new Error(`getPolicySettings failed with status : ${P.status}`);const f=await P.json();return{id:f?.id,moreInfoUrl:o?f?.helpWebUrl:f?.moreInfoUrl,isDowngradeJustificationRequired:o?f?.downgradeSensitivityRequiresJustification:f?.isDowngradeJustificationRequired,isMandatory:f?.isMandatory,defaultLabelId:o?f?.outlookEmailSettings?.defaultLabel:f?.defaultLabelId}}(t,this.createAttributionHeaders(e),i,s,r);return o.setResult(!0,{infoUrl:!!a.moreInfoUrl,isMandatory:a.isMandatory,isDefault:!!a.defaultLabelId,isDowngradeJustificationRequired:a.isDowngradeJustificationRequired}),a}catch(a){return this.PromiseCache.delete(_.PolicySettings.toString()),void o.setResult(!1,{errorType:q.N.GetPolicySettingsError},a)}})(),this.PromiseCache.set(_.PolicySettings.toString(),a),a.then()}async getWatermarkInformation(e,t){const[i,s,a]=await Promise.all([this.tokenProviderPromise,this.loggerPromise,this.settingsProviderPromise]);if((0,b.N1)(a)){if(!1===await this.getSupportsCLP(e,t))return}const o=V.m.start("GetWatermarking",s);if(this.isAssignedMode(a)){let e;if(this.assignedSensitivityLabelId){let t;const i=await this.getLabels("AUO",!0);i&&(t=n(i,this.assignedSensitivityLabelId)),e=t?.watermark}return o.setResult(!0,{appliedLabel:!!this.assignedSensitivityLabelId,assignedMode:this.assignedMode}),e}if(!e||!(0,r.g2)(e))return void(s&&(0,J.Ot)(s,{eventName:q.N.InvalidResolvedUrl,scenario:F.N.GetWatermarking}));const l=this.getCacheKey(_.Watermark,e.hashedDocumentId);let d=l&&this.PromiseCache.get(l);return d||(d=(async()=>{try{const r=await this.getCurrentLabel(e,t);let d;if(r){if(void 0===i)throw new Error("TokenProvider is not available");if((0,b.i4)(a)){const e=await this.getLabels("AUO",!0);if(e){const t=n(e,r.sensitivityLabelId);d=t?.watermark,o.setResult(!0,{appliedLabel:!0,isWatermark:!!d})}else l&&this.PromiseCache.delete(l),o.setResult(!1,{errorType:q.N.GetWatermarkingError})}else{const e=await G(i,r.sensitivityLabelId,this.createAttributionHeaders(t),void 0,void 0,s,a);this.labelMetadataCache=e.contentInfo,d=e.watermark,o.setResult(!0,{appliedLabel:!0,isWatermark:!!e.watermark,isContentInfo:!!e.contentInfo})}return d}return void o.setResult(!0,{appliedLabel:!!r})}catch(r){return l&&this.PromiseCache.delete(l),void o.setResult(!1,{errorType:q.N.GetWatermarkingError},r)}})(),l&&this.PromiseCache.set(l,d),d.then())}async overrideDlpPolicyTip(e){throw new Error("Not Implemented..")}async getLabels(e,t){const[i,s,r,a]=await Promise.all([this.tokenProviderPromise,this.loggerPromise,this.settingsProviderPromise,this.userContextPromise]),o=t?_.UnfilteredLabels.toString():_.Labels.toString();let n=this.PromiseCache.get(o);if(n)return n;const l=V.m.start("GetLabels",s);return n=(async()=>{try{if(void 0===i)throw new Error("TokenProvider is not available");const o=await T(t??!1,i,this.createAttributionHeaders(e),s,r,a);return l.setResult(!0),o}catch(n){return this.PromiseCache.delete(o),void l.setResult(!1,{errorType:q.N.GetLabelsError},n)}})(),this.PromiseCache.set(o,n),n.then()}async changeLabel(e,t,i){const[s,a,o]=await Promise.all([this.tokenProviderPromise,this.loggerPromise,this.settingsProviderPromise]);if(!(0,r.g2)(e))return!1;if((0,b.N1)(o)){if(!1===await this.getSupportsCLP(e,i))return!1}if(void 0===s)throw new Error("TokenProvider is not available");const n=await async function(e,t,i,s,r,a,o,n){const c=(0,u.$)(s),h=H(a,"SetLabel"),g=new AbortController,p={getToken:r=>{if(r){const a={...r,siteUrl:s,driveId:i,itemId:t};return e.getToken([`${c}/files.readwrite.all`],a)}throw Error("Options must be specified")},url:`${c}/_api/v2.0/drives/${i}/items/${t}/setSensitivityLabel`,requestInit:{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r),signal:g.signal},retryPolicy:y(n,!0),timeoutMs:I,additionalRequestHeaders:h},m=o?await(0,l.g)({...p,logger:o,nameForLogging:"SetLabel",getAdditionalProps:async(e,t)=>({...(0,d.u)(e),include404:(0,b.s5)(n)})}):await(0,l.y)(p);return g.abort(),200===m.result.status}(s,e.itemId,e.driveId,e.siteUrl,t,this.createAttributionHeaders(i),a,o);return n&&this.refreshAppliedLabel(e,i),n}async isLabelChangeAnUpgrade(e,t,i,s){return(async()=>{const[r,a]=await Promise.all([this.getCurrentLabel(e,s),this.getLabels(s)]);if(!r)return!0;if(!a)return i.addAdditionalProps({setIfUpgradeFailure:"noLabelsFound"}),!1;if(null==t.id)return i.addAdditionalProps({setIfUpgradeFailure:"labelIdMissing"}),!1;const o=n(a,r.sensitivityLabelId),l=n(a,t.id);return l?!o||l.sensitivity>=o.sensitivity||(i.addAdditionalProps({setIfUpgradeFailure:"isSensitivityDowngrade"}),!1):(i.addAdditionalProps({setIfUpgradeFailure:"proposedLabelNotFound"}),!1)})().then()}async setCurrentLabel(e,t,i,s){const[a,o,n]=await Promise.all([this.tokenProviderPromise,this.loggerPromise,this.settingsProviderPromise]);if(!(0,b.E7)(n)){return V.m.start("SetLabel",o).setResult(!1,{settingName:b.LV,settingValue:(0,b.E7)(n),settingsProviderExists:void 0!==n}),!1}const l=V.m.start("SetLabel",o);if(this.isAssignedMode(n)){const s=await this.isLabelChangeAnUpgrade(e,t,l,i);return s?(this.assignedSensitivityLabelId=t.id??void 0,l.setResult(s,{changeLabel:!0,changeLabelStatus:!0,setIfUpgrade:!0,sensitivityLabelId:t.id||"",supportsCLP:this.assignedCapabilities?.supportsCLP,callingEvaluate:!1,assignedMode:this.assignedMode}),!0):(l.setResult(!1,{errorType:q.N.SetLabelError,setIfUpgrade:s,sensitivityLabelId:t.id||"",supportsCLP:this.assignedCapabilities?.supportsCLP,assignedMode:this.assignedMode}),!1)}if(!e||!(0,r.g2)(e))return o&&(0,J.Ot)(o,{eventName:q.N.InvalidResolvedUrl,scenario:F.N.SetLabel}),!1;if(null===t.id)return o&&(0,J.Ot)(o,{eventName:q.N.InvalidLabelId,scenario:F.N.SetLabel}),!1;let d,c=!0;const u=await this.getSupportsCLP(e,i);try{if(void 0===a)throw new Error("TokenProvider is not available");s&&(d=await this.isLabelChangeAnUpgrade(e,t,l,i),l.addAdditionalProps({setIfUpgrade:d}),d||(l.setResult(!1,{errorType:q.N.SetLabelError,assignmentMethod:t.assignmentMethod,actionSource:t.actionSource,sensitivityLabelId:t.id,ifMatchLabelId:t.ifMatchLabelId,supportsCLP:u,assignedMode:this.assignedMode}),c=!1));const r=!(0,b.i4)(n);let h;!1!==d&&(r?(h=await G(a,t.id,this.createAttributionHeaders(i),t.justificationText,this.labelMetadataCache,o,n),h.changeLabel&&!1!==u&&(c=await this.changeLabel(e,t,i))):!1!==u&&(c=await this.changeLabel(e,t,i)),l.setResult(c,{changeLabel:h?.changeLabel,changeLabelStatus:c,assignmentMethod:t.assignmentMethod,actionSource:t.actionSource,sensitivityLabelId:t.id,ifMatchLabelId:t.ifMatchLabelId,supportsCLP:u,callingEvaluate:r,assignedMode:this.assignedMode}))}catch(h){l.setResult(!1,{errorType:q.N.SetLabelError,assignmentMethod:t.assignmentMethod,actionSource:t.actionSource,sensitivityLabelId:t.id,ifMatchLabelId:t.ifMatchLabelId,supportsCLP:u,assignedMode:this.assignedMode},h),c=!1}return c||!1===d||this.emit("sensitivityError"),c}async removeCurrentLabel(e,t,i){const[s,a,o]=await Promise.all([this.tokenProviderPromise,this.loggerPromise,this.settingsProviderPromise]);if(!(0,b.E7)(o)){return V.m.start("RemoveLabel",a).setResult(!1,{settingName:b.LV,settingValue:(0,b.E7)(o),settingsProviderExists:void 0!==o}),!1}const n=V.m.start("RemoveLabel",a);if(null===t.id)return a&&(0,J.Ot)(a,{eventName:q.N.InvalidLabelId,scenario:F.N.SetLabel,assignedMode:this.assignedMode}),!1;if(this.isAssignedMode(o))return this.assignedSensitivityLabelId=void 0,n.setResult(!0,{changeLabel:!0,removeCurrentLabelStatus:!0,stopEvaluate:!1,assignedMode:this.assignedMode}),!0;if(!e||!(0,r.g2)(e))return a&&(0,J.Ot)(a,{eventName:q.N.InvalidResolvedUrl,scenario:F.N.RemoveLabel}),!1;let l=!0;const d=await this.getSupportsCLP(e,i);try{if(void 0===s)throw new Error("TokenProvider is not available");const r=(0,b.i4)(o);let u;!1!==d&&(r||(u=await async function(e,t,i,s,r,a,o){const n=E(o?.audience??"Production")+"me/security/informationProtection/sensitivityLabels/evaluateRemoval",l=H(i,"EvaluateRemoval"),d={contentInfo:s||D(t),downgradeJustification:{isDowngradeJustified:!!r,justificationMessage:r||""}},u=new AbortController,h=await(0,c.fV)(t=>e.getToken(M,t),n,o?.audience??"Production","EvaluateRemoval",a,void 0,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(d),signal:u.signal},v(o),I,void 0,l);if(!h.ok||200!==h.status)throw u.abort(),new Error(`evaluateLabelRemoval failed with status : ${h.status}`);const g=C(await h.json());return g?.metadataToRemove?{changeLabel:!0}:{changeLabel:!1}}(s,t.id,this.createAttributionHeaders(i),this.labelMetadataCache,t.justificationText,a,o)),(u?.changeLabel||r)&&(t.id=null,l=await this.changeLabel(e,t,i),l&&(this.labelMetadataCache=void 0))),n.setResult(!0,{changeLabel:u?.changeLabel,removeCurrentLabelStatus:l,assignmentMethod:t.assignmentMethod,actionSource:t.actionSource,supportsCLP:d,stopEvaluate:r,assignedMode:this.assignedMode})}catch(u){n.setResult(!1,{errorType:q.N.RemoveLabelError,supportsCLP:d,assignedMode:this.assignedMode},u),l=!1}return l||this.emit("sensitivityError"),l}async getDlpTooltip(e,t){const[i,s,a,o]=await Promise.all([this.tokenProviderPromise,this.loggerPromise,this.settingsProviderPromise,this.trustedTypesPolicyPromise]);if(this.isAssignedMode(a))throw new Error("DLP policy tip is not supported in assigned mode");if(!(0,b.y6)(a))return;if(!(0,r.g2)(e))return void(s&&(0,J.Ot)(s,{eventName:q.N.InvalidResolvedUrl,scenario:F.N.GetDlpPolicyTip}));const n=this.getCacheKey(_.DlpPolicyTip,e.hashedDocumentId);let l=n&&this.PromiseCache.get(n);if(l)return l;const d=V.m.start("GetDlpPolicyTip",s);return l=(async()=>{try{if(void 0===i)throw new Error("TokenProvider is not available");const r=await $(i,e.itemId,e.driveId,e.siteUrl,o,this.createAttributionHeaders(t),s,a);return r&&this.emit("dlpPolicyTip",r),d.setResult(!0,{tip:!!r,moreInfoUrl:!!r?.complianceUrl,overrideOptions:r?.overrideOptions}),r}catch(r){return n&&this.PromiseCache.delete(n),void d.setResult(!1,{errorType:q.N.GetDlpPolicyTipError},r)}})(),n&&this.PromiseCache.set(n,l),l.then()}async getIsMandatoryLabeling(e,t){const[i,s]=await Promise.all([this.loggerPromise,this.settingsProviderPromise]);if(!(0,b.E7)(s)){return V.m.start("IsMandatoryLabelingRequired",i).setResult(!1,{settingName:b.LV,settingValue:(0,b.E7)(s),settingsProviderExists:void 0!==s}),!1}if(this.isAssignedMode(s))throw new Error("getIsMandatoryLabeling is not supported in assigned mode");if(!(0,r.g2)(e))return void(i&&(0,J.Ot)(i,{eventName:q.N.InvalidResolvedUrl,scenario:F.N.GetIsProtectionEnabled}));if((0,b.N1)(s)){if(!1===await this.getSupportsCLP(e,t))return!1}const a=this.getCacheKey(_.IsMandatoryLabelingRequired,e.hashedDocumentId);let o=a&&this.PromiseCache.get(a);if(o)return o;const n=V.m.start("IsMandatoryLabelingRequired",i);return o=(async()=>{const e=await this.getPolicySettings(t);if(!e)return n.setResult(!1,{policySettings:!!e}),void(a&&this.PromiseCache.delete(a));const i=e.isMandatory;return n.setResult(!0,{isMandatoryLabelingRequired:i}),i})(),a&&this.PromiseCache.set(a,o),o.then()}async enforceMandatoryLabelExperience(e,t){const[i,s]=await Promise.all([this.loggerPromise,this.settingsProviderPromise]);if(!(0,b.E7)(s)||!(0,b.vY)(s))return;if(this.isAssignedMode(s))throw new Error("enforceMandatoryLabelExperience is not supported in assigned mode");if((0,b.N1)(s)){if(!1===await this.getSupportsCLP(e,t))return}if(!(0,r.g2)(e))return void(i&&(0,J.Ot)(i,{eventName:q.N.InvalidResolvedUrl,scenario:F.N.EnforceMandatoryLabelExperience}));const a=V.m.start("EnforceMandatoryLabelExperience",i),[o,n]=await Promise.all([this.getPolicySettings(t),this.getCurrentLabel(e,t)]);o?.isMandatory&&!n&&(o.defaultLabelId?this.delayExecuteMandatoryLabeling(e,1e4,t):this.executeMandatoryLabeling()),a.setResult(!0)}delayExecuteMandatoryLabeling(e,t,i){this.mandatoryLabelTimeout||(this.mandatoryLabelTimeout=window.setTimeout(async()=>{await this.getCurrentLabel(e,i)||this.executeMandatoryLabeling()},t))}async initialize(e){const[t]=await Promise.all([this.loggerPromise]),i=V.m.start("Initialization",t);await Promise.all([this.getLabels(e),this.getPolicySettings(e)]),i.setResult(!0)}async monitorAppliedLabel(e){const[t]=await Promise.all([this.loggerPromise]);if(window.clearInterval(this.refreshTimer),!this.disposed){const i=9e5;this.refreshTimer=window.setInterval(async()=>{t&&(0,J.Ot)(t,{eventName:W.S.RefreshTimerTriggered}),await this.refreshAppliedLabel(e,"AUO")},i)}}async refreshAppliedLabel(e,t){const[i,s]=await Promise.all([this.loggerPromise,this.settingsProviderPromise]);if(!(0,r.g2)(e))return;if((0,b.N1)(s)){if(!1===await this.getSupportsCLP(e,t))return}const a=V.m.start("RefreshAppliedLabel",i),o=(0,b.jP)(s),n=await this.getCurrentLabel(e,t,o),l=this.getCacheKey(_.AppliedLabel,e.hashedDocumentId);l&&this.PromiseCache.delete(l);const d=await this.getCurrentLabel(e,t,o),c=n?.sensitivityLabelId!==d?.sensitivityLabelId;if(c){this.emit("sensitivityLabelChanged",d);const i=this.getCacheKey(_.IrmCapabilities,e.hashedDocumentId);i&&this.PromiseCache.delete(i);const s=this.getCacheKey(_.Watermark,e.hashedDocumentId);s&&this.PromiseCache.delete(s);const[r,a]=await Promise.all([this.getIrmInformation(e,t),this.getWatermarkInformation(e,t)]);this.emit("IrmCapabilitiesChanged",r),this.emit("watermarkingChanged",a);const o=this.getCacheKey(_.IsProtectionEnabled,e.hashedDocumentId);o&&this.PromiseCache.delete(o);const n=await this.getHasProtection(e,t);this.emit("protectionChanged",n)}a.setResult(!0,{isRefreshed:c})}async processPolicySettings(e,t,i){const[s,r]=await Promise.all([this.loggerPromise,this.settingsProviderPromise]),a=V.m.start("ProcessPolicySettings",s);if(!(0,b.E7)(r)||this.isAssignedMode(r))return void a.setResult(!0,{settingName:b.LV,settingValue:(0,b.E7)(r),settingsProviderExists:void 0!==r,assignedMode:this.assignedMode});const o=await this.getPolicySettings(i||"AUO"),n=await this.getLabels(i);if(!o)return void a.setResult(!1,{errorType:q.N.GetPolicySettingsError,scenario:F.N.ProcessPolicySettings});let l=!1;this.existingHostLabel&&(0,b.M6)(r)&&(l=await this.executeInheritedLabeling(e,i),a.addAdditionalProps({executeInheritedLabel:l}));let d,c=!1;d=(0,b.yg)(r)&&(0,b.ZU)(r)?function(e){if(e&&0!==e.length)for(const t of e)if(t.isDefault&&t.id!==f)return t.id}(n):o.defaultLabelId===f?void 0:o.defaultLabelId,l||!d||t?.sensitivityLabelId||(c=await this.executeDefaultLabeling(e,d,i),a.addAdditionalProps({defaultLabelingStatus:c}));let u=!1;o.isMandatory&&!t?.sensitivityLabelId&&(0,b.vY)(r)&&(d&&(c||l)||(u=!0,this.executeMandatoryLabeling())),a.setResult(!0,{isDefault:!!d,executeInheritedLabel:l,defaultLabelingStatus:c,isMandatory:o.isMandatory,executeMandatoryLabel:u})}async executeDefaultLabeling(e,t,i){const[s]=await Promise.all([this.settingsProviderPromise]);if(!(0,b.E7)(s))return!1;const r={id:t,assignmentMethod:"standard",actionSource:"defaultLabel"};return await this.setCurrentLabel(e,r,i)}async executeInheritedLabeling(e,t){const[i]=await Promise.all([this.loggerPromise]),s=V.m.start("ExecuteInheritedLabeling",i);if(!this.existingHostLabel)return s.setResult(!1),!1;const r=this.existingHostLabel.sensitivityLabelId,a={id:r,assignmentMethod:"auto",actionSource:"auto"},o=await this.setCurrentLabel(e,a,t);return s.setResult(o,{existingHostLabel:r}),o&&(this.existingHostLabel=void 0),o}async executeMandatoryLabeling(){const[e]=await Promise.all([this.settingsProviderPromise]);(0,b.E7)(e)&&this.emit("mandatoryLabelRequired"),this.mandatoryLabelTimeout&&window.clearTimeout(this.mandatoryLabelTimeout)}}const Y=z.serviceFactory}}]);
//# sourceMappingURL=SharepointInformationProtectionService.ee40b403.chunk.js.map